"""
Vulnerability Scanner Module
Scans for common security vulnerabilities and misconfigurations.
"""

import socket
import ssl
import requests
import subprocess
import re
from colorama import Fore, Style
from tabulate import tabulate
import urllib3
from datetime import datetime, timedelta
import dns.resolver

# Disable SSL warnings for testing
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class VulnerabilityScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 3389, 5900]
        self.ssl_vulnerabilities = []
        
    def check_ssl_vulnerabilities(self, target, port=443):
        """Check for SSL/TLS vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check SSL certificate
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.create_connection((target, port), timeout=10)
            ssock = context.wrap_socket(sock, server_hostname=target)
            
            cert = ssock.getpeercert()
            protocol = ssock.version()
            cipher = ssock.cipher()
            
            # Check protocol version
            if protocol in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                vulnerabilities.append({
                    'type': 'SSL/TLS',
                    'severity': 'High',
                    'description': f'Weak SSL/TLS protocol: {protocol}',
                    'recommendation': 'Upgrade to TLS 1.2 or higher'
                })
            
            # Check cipher strength
            if cipher and cipher[1] < 128:
                vulnerabilities.append({
                    'type': 'SSL/TLS',
                    'severity': 'Medium',
                    'description': f'Weak cipher: {cipher[0]} ({cipher[1]} bits)',
                    'recommendation': 'Use stronger ciphers (AES-256 or higher)'
                })
            
            # Check certificate expiration
            if cert:
                not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                days_until_expiry = (not_after - datetime.now()).days
                
                if days_until_expiry < 30:
                    severity = 'High' if days_until_expiry < 0 else 'Medium'
                    vulnerabilities.append({
                        'type': 'SSL/TLS',
                        'severity': severity,
                        'description': f'Certificate expires in {days_until_expiry} days',
                        'recommendation': 'Renew SSL certificate'
                    })
            
            ssock.close()
            
        except Exception as e:
            vulnerabilities.append({
                'type': 'SSL/TLS',
                'severity': 'Info',
                'description': f'SSL check failed: {str(e)}',
                'recommendation': 'Verify SSL configuration'
            })
        
        return vulnerabilities
    
    def check_http_vulnerabilities(self, target, port=80, use_ssl=False):
        """Check for HTTP-related vulnerabilities"""
        vulnerabilities = []
        protocol = 'https' if use_ssl else 'http'
        url = f"{protocol}://{target}:{port}"
        
        try:
            # Check HTTP methods
            response = requests.options(url, timeout=10, verify=False)
            allowed_methods = response.headers.get('Allow', '').split(',')
            dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'CONNECT']
            
            for method in dangerous_methods:
                if method in allowed_methods:
                    vulnerabilities.append({
                        'type': 'HTTP',
                        'severity': 'Medium',
                        'description': f'Dangerous HTTP method enabled: {method}',
                        'recommendation': f'Disable {method} method if not needed'
                    })
            
            # Check security headers
            response = requests.get(url, timeout=10, verify=False)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection',
                'X-Content-Type-Options': 'MIME type sniffing protection',
                'X-XSS-Protection': 'XSS protection',
                'Strict-Transport-Security': 'HTTPS enforcement',
                'Content-Security-Policy': 'XSS and injection protection'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'type': 'HTTP',
                        'severity': 'Low',
                        'description': f'Missing security header: {header}',
                        'recommendation': f'Add {header} header for {description}'
                    })
            
            # Check for information disclosure
            server_header = headers.get('Server', '')
            if server_header:
                vulnerabilities.append({
                    'type': 'HTTP',
                    'severity': 'Low',
                    'description': f'Server information disclosed: {server_header}',
                    'recommendation': 'Hide or minimize server information'
                })
            
            # Check for directory listing
            dir_listing_indicators = ['Index of /', 'Directory Listing', '<title>Index of']
            response_text = response.text.lower()
            
            for indicator in dir_listing_indicators:
                if indicator.lower() in response_text:
                    vulnerabilities.append({
                        'type': 'HTTP',
                        'severity': 'Medium',
                        'description': 'Directory listing enabled',
                        'recommendation': 'Disable directory listing'
                    })
                    break
            
        except Exception as e:
            vulnerabilities.append({
                'type': 'HTTP',
                'severity': 'Info',
                'description': f'HTTP check failed: {str(e)}',
                'recommendation': 'Verify web server configuration'
            })
        
        return vulnerabilities
    
    def check_ssh_vulnerabilities(self, target, port=22):
        """Check for SSH vulnerabilities"""
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((target, port))
            
            # Get SSH banner
            banner = sock.recv(1024).decode('utf-8').strip()
            sock.close()
            
            # Check SSH version
            if 'SSH-1.' in banner:
                vulnerabilities.append({
                    'type': 'SSH',
                    'severity': 'High',
                    'description': 'SSH version 1.x detected (vulnerable)',
                    'recommendation': 'Upgrade to SSH version 2.x'
                })
            
            # Check for old OpenSSH versions with known vulnerabilities
            if 'OpenSSH' in banner:
                version_match = re.search(r'OpenSSH_(\d+\.\d+)', banner)
                if version_match:
                    version = float(version_match.group(1))
                    if version < 7.4:
                        vulnerabilities.append({
                            'type': 'SSH',
                            'severity': 'Medium',
                            'description': f'Outdated OpenSSH version: {version}',
                            'recommendation': 'Update to latest OpenSSH version'
                        })
            
            vulnerabilities.append({
                'type': 'SSH',
                'severity': 'Info',
                'description': f'SSH banner: {banner}',
                'recommendation': 'Consider hiding SSH version information'
            })
            
        except Exception as e:
            pass  # SSH not available or connection failed
        
        return vulnerabilities
    
    def check_dns_vulnerabilities(self, target):
        """Check for DNS-related vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for DNS zone transfer
            try:
                answers = dns.resolver.resolve(target, 'AXFR')
                vulnerabilities.append({
                    'type': 'DNS',
                    'severity': 'High',
                    'description': 'DNS zone transfer allowed',
                    'recommendation': 'Restrict zone transfers to authorized servers only'
                })
            except:
                pass  # Zone transfer not allowed (good)
            
            # Check for DNS recursion
            try:
                resolver = dns.resolver.Resolver()
                resolver.nameservers = [target]
                resolver.resolve('google.com', 'A')
                
                vulnerabilities.append({
                    'type': 'DNS',
                    'severity': 'Medium',
                    'description': 'DNS recursion enabled',
                    'recommendation': 'Disable DNS recursion for external queries'
                })
            except:
                pass  # Recursion not enabled (good)
            
        except Exception as e:
            pass  # DNS checks failed
        
        return vulnerabilities
    
    def check_smb_vulnerabilities(self, target):
        """Check for SMB vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check if SMB ports are open
            smb_ports = [139, 445]
            open_smb_ports = []
            
            for port in smb_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                if sock.connect_ex((target, port)) == 0:
                    open_smb_ports.append(port)
                sock.close()
            
            if open_smb_ports:
                vulnerabilities.append({
                    'type': 'SMB',
                    'severity': 'Medium',
                    'description': f'SMB ports open: {", ".join(map(str, open_smb_ports))}',
                    'recommendation': 'Ensure SMB is properly secured and up-to-date'
                })
                
                # Check for SMBv1
                if 139 in open_smb_ports:
                    vulnerabilities.append({
                        'type': 'SMB',
                        'severity': 'High',
                        'description': 'SMBv1 may be enabled (port 139 open)',
                        'recommendation': 'Disable SMBv1 and use SMBv2/v3 only'
                    })
        
        except Exception as e:
            pass  # SMB checks failed
        
        return vulnerabilities
    
    def scan_target(self, target, quick_scan=False):
        """Main vulnerability scanning function"""
        print(f"{Fore.BLUE}[*] Starting vulnerability scan on {target}...{Style.RESET_ALL}")
        
        self.vulnerabilities = []
        
        # Resolve target to IP if it's a hostname
        try:
            ip_address = socket.gethostbyname(target)
            print(f"{Fore.CYAN}[*] Target resolved to: {ip_address}{Style.RESET_ALL}")
        except:
            ip_address = target
        
        # Port scan to determine available services
        print(f"{Fore.CYAN}[*] Scanning for open ports...{Style.RESET_ALL}")
        open_ports = self.quick_port_scan(ip_address)
        
        if not open_ports:
            print(f"{Fore.YELLOW}[!] No open ports found{Style.RESET_ALL}")
            return []
        
        print(f"{Fore.GREEN}[+] Found {len(open_ports)} open ports: {', '.join(map(str, open_ports))}{Style.RESET_ALL}")
        
        # Check vulnerabilities based on open ports
        if 80 in open_ports:
            print(f"{Fore.CYAN}[*] Checking HTTP vulnerabilities...{Style.RESET_ALL}")
            self.vulnerabilities.extend(self.check_http_vulnerabilities(target, 80, False))
        
        if 443 in open_ports:
            print(f"{Fore.CYAN}[*] Checking HTTPS/SSL vulnerabilities...{Style.RESET_ALL}")
            self.vulnerabilities.extend(self.check_ssl_vulnerabilities(target, 443))
            self.vulnerabilities.extend(self.check_http_vulnerabilities(target, 443, True))
        
        if 22 in open_ports:
            print(f"{Fore.CYAN}[*] Checking SSH vulnerabilities...{Style.RESET_ALL}")
            self.vulnerabilities.extend(self.check_ssh_vulnerabilities(target, 22))
        
        if 53 in open_ports:
            print(f"{Fore.CYAN}[*] Checking DNS vulnerabilities...{Style.RESET_ALL}")
            self.vulnerabilities.extend(self.check_dns_vulnerabilities(ip_address))
        
        if 139 in open_ports or 445 in open_ports:
            print(f"{Fore.CYAN}[*] Checking SMB vulnerabilities...{Style.RESET_ALL}")
            self.vulnerabilities.extend(self.check_smb_vulnerabilities(ip_address))
        
        # Additional checks for quick scan
        if not quick_scan:
            print(f"{Fore.CYAN}[*] Performing additional security checks...{Style.RESET_ALL}")
            self.check_additional_vulnerabilities(target, open_ports)
        
        print(f"{Fore.GREEN}[+] Vulnerability scan completed{Style.RESET_ALL}")
        return self.vulnerabilities
    
    def quick_port_scan(self, target):
        """Quick port scan to identify open services"""
        open_ports = []
        
        for port in self.common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                if sock.connect_ex((target, port)) == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass
        
        return open_ports
    
    def check_additional_vulnerabilities(self, target, open_ports):
        """Additional vulnerability checks for comprehensive scan"""
        
        # Check for common default credentials
        if 22 in open_ports:  # SSH
            self.vulnerabilities.append({
                'type': 'Authentication',
                'severity': 'Info',
                'description': 'SSH service detected - check for weak credentials',
                'recommendation': 'Ensure strong passwords/keys and disable root login'
            })
        
        if 21 in open_ports:  # FTP
            self.vulnerabilities.append({
                'type': 'FTP',
                'severity': 'Medium',
                'description': 'FTP service detected',
                'recommendation': 'Use SFTP/FTPS instead of plain FTP'
            })
        
        if 23 in open_ports:  # Telnet
            self.vulnerabilities.append({
                'type': 'Telnet',
                'severity': 'High',
                'description': 'Telnet service detected (unencrypted)',
                'recommendation': 'Replace Telnet with SSH'
            })
        
        if 3389 in open_ports:  # RDP
            self.vulnerabilities.append({
                'type': 'RDP',
                'severity': 'Medium',
                'description': 'RDP service detected',
                'recommendation': 'Secure RDP with strong authentication and network restrictions'
            })
    
    def display_results(self, vulnerabilities):
        """Display vulnerability scan results"""
        if not vulnerabilities:
            print(f"{Fore.GREEN}[+] No vulnerabilities found{Style.RESET_ALL}")
            return
        
        print(f"\n{Fore.RED}[!] Vulnerability Scan Results{Style.RESET_ALL}")
        print(f"{Fore.RED}[!] Found {len(vulnerabilities)} potential issues{Style.RESET_ALL}\n")
        
        # Group by severity
        severity_groups = {'High': [], 'Medium': [], 'Low': [], 'Info': []}
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Info')
            severity_groups[severity].append(vuln)
        
        # Display by severity
        severity_colors = {
            'High': Fore.RED,
            'Medium': Fore.YELLOW,
            'Low': Fore.CYAN,
            'Info': Fore.WHITE
        }
        
        for severity in ['High', 'Medium', 'Low', 'Info']:
            vulns = severity_groups[severity]
            if vulns:
                color = severity_colors[severity]
                print(f"{color}[{severity}] {len(vulns)} issue(s){Style.RESET_ALL}")
                
                table_data = []
                for vuln in vulns:
                    table_data.append([
                        vuln.get('type', 'Unknown'),
                        vuln.get('description', '')[:60] + "..." if len(vuln.get('description', '')) > 60 else vuln.get('description', ''),
                        vuln.get('recommendation', '')[:60] + "..." if len(vuln.get('recommendation', '')) > 60 else vuln.get('recommendation', '')
                    ])
                
                print(tabulate(table_data, headers=['Type', 'Description', 'Recommendation'], tablefmt='grid'))
                print()
        
        # Summary
        total_high = len(severity_groups['High'])
        total_medium = len(severity_groups['Medium'])
        total_low = len(severity_groups['Low'])
        
        print(f"{Fore.CYAN}[*] Summary:{Style.RESET_ALL}")
        print(f"  Total vulnerabilities: {len(vulnerabilities)}")
        print(f"  High severity: {total_high}")
        print(f"  Medium severity: {total_medium}")
        print(f"  Low severity: {total_low}")
        
        if total_high > 0:
            print(f"{Fore.RED}[!] Immediate attention required for {total_high} high-severity issues{Style.RESET_ALL}")
        elif total_medium > 0:
            print(f"{Fore.YELLOW}[!] {total_medium} medium-severity issues should be addressed{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No critical vulnerabilities detected{Style.RESET_ALL}")